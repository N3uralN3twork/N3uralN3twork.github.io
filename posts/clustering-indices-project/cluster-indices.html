<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Matthias Quinn">
<meta name="dcterms.date" content="2023-01-22">
<meta name="description" content="This project was the seminal work of my master’s degree in statistics.">

<title>N3uralN3twork’s Website - Cluster Validity Indices</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/Combo-Chart-Icon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<style>
    .quarto-title-block .quarto-title-banner {
      background: #FFAC1C;
    }
    </style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">Cluster Validity Indices</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title d-none d-lg-block">Cluster Validity Indices</h1>
                  <div>
        <div class="description">
          This project was the seminal work of my master’s degree in statistics.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">ML</div>
                <div class="quarto-category">algorithms</div>
                <div class="quarto-category">college</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Matthias Quinn </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 22, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="../../index.html" class="sidebar-logo-link">
      <img src="../../images/Transhumanism Logo for Website.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/N3uralN3twork/n3uraln3twork.github.io" title="Website" class="sidebar-tool px-1"><i class="bi bi-globe"></i></a>
    <a href="https://github.com/N3uralN3twork" title="Personal Github" class="sidebar-tool px-1"><i class="bi bi-github"></i></a>
    <a href="https://www.linkedin.com/in/matthiasquinn" title="Personal Linkedin" class="sidebar-tool px-1"><i class="bi bi-linkedin"></i></a>
    <a href="mailto:miq_qedquinn@yahoo.com" title="Contact Me" class="sidebar-tool px-1"><i class="bi bi-question-circle"></i></a>
  <a href="" class="quarto-color-scheme-toggle sidebar-tool" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">Welcome</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../aboutme.html" class="sidebar-item-text sidebar-link">Who am I?</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../resumes.html" class="sidebar-item-text sidebar-link">Resumes</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../projects.html" class="sidebar-item-text sidebar-link">Projects</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pytorch.html" class="sidebar-item-text sidebar-link">PyTorch</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../publications.html" class="sidebar-item-text sidebar-link">Papers</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1. Introduction</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods"><strong>2. Methods</strong></a>
  <ul class="collapse">
  <li><a href="#language" id="toc-language" class="nav-link" data-scroll-target="#language">2.1 Language</a></li>
  <li><a href="#related-work" id="toc-related-work" class="nav-link" data-scroll-target="#related-work">2.2 Related Work</a></li>
  </ul></li>
  <li><a href="#clustering-algorithms" id="toc-clustering-algorithms" class="nav-link" data-scroll-target="#clustering-algorithms">3. Clustering Algorithms</a>
  <ul class="collapse">
  <li><a href="#k-means" id="toc-k-means" class="nav-link" data-scroll-target="#k-means">3.1 K-Means</a>
  <ul class="collapse">
  <li><a href="#the-k-means-algorithm" id="toc-the-k-means-algorithm" class="nav-link" data-scroll-target="#the-k-means-algorithm">3.1.1 The K-Means Algorithm</a></li>
  <li><a href="#time-and-space-complexity" id="toc-time-and-space-complexity" class="nav-link" data-scroll-target="#time-and-space-complexity">3.1.2 Time and Space Complexity</a></li>
  </ul></li>
  <li><a href="#agglomerative-hierarchical-clustering" id="toc-agglomerative-hierarchical-clustering" class="nav-link" data-scroll-target="#agglomerative-hierarchical-clustering">3.2 Agglomerative Hierarchical Clustering</a>
  <ul class="collapse">
  <li><a href="#agglomerative-hierarchical-clustering-algorithm" id="toc-agglomerative-hierarchical-clustering-algorithm" class="nav-link" data-scroll-target="#agglomerative-hierarchical-clustering-algorithm">3.2.1 Agglomerative Hierarchical Clustering Algorithm</a></li>
  <li><a href="#time-and-space-complexity-1" id="toc-time-and-space-complexity-1" class="nav-link" data-scroll-target="#time-and-space-complexity-1">3.2.2 Time and Space Complexity</a></li>
  </ul></li>
  <li><a href="#dbscan" id="toc-dbscan" class="nav-link" data-scroll-target="#dbscan">3.3 DBSCAN</a></li>
  </ul></li>
  <li><a href="#internal-cluster-validity-indices" id="toc-internal-cluster-validity-indices" class="nav-link" data-scroll-target="#internal-cluster-validity-indices">4. Internal Cluster Validity Indices</a>
  <ul class="collapse">
  <li><a href="#notation" id="toc-notation" class="nav-link" data-scroll-target="#notation">4.0 Notation:</a></li>
  <li><a href="#ball-hall-index" id="toc-ball-hall-index" class="nav-link" data-scroll-target="#ball-hall-index">4.1 </a><a name="bhindex" class="nav-link" data-scroll-target="undefined"></a>Ball-Hall Index</li>
  <li><a href="#the-beale-index" id="toc-the-beale-index" class="nav-link" data-scroll-target="#the-beale-index">4.2 The Beale Index</a></li>
  <li><a href="#the-c-index" id="toc-the-c-index" class="nav-link" data-scroll-target="#the-c-index">4.3 The C Index</a></li>
  <li><a href="#the-calinski-harabasz-index" id="toc-the-calinski-harabasz-index" class="nav-link" data-scroll-target="#the-calinski-harabasz-index">4.4 The Calinski-Harabasz Index</a></li>
  <li><a href="#cubic-clustering-criterion" id="toc-cubic-clustering-criterion" class="nav-link" data-scroll-target="#cubic-clustering-criterion">4.5 Cubic Clustering Criterion</a></li>
  <li><a href="#d-index" id="toc-d-index" class="nav-link" data-scroll-target="#d-index">4.6 D Index</a></li>
  <li><a href="#davies-bouldin-index" id="toc-davies-bouldin-index" class="nav-link" data-scroll-target="#davies-bouldin-index">4.7 Davies-Bouldin Index</a></li>
  <li><a href="#duda-index" id="toc-duda-index" class="nav-link" data-scroll-target="#duda-index">4.8 Duda Index</a></li>
  <li><a href="#dunn-index" id="toc-dunn-index" class="nav-link" data-scroll-target="#dunn-index">4.9 Dunn Index</a></li>
  <li><a href="#frey-index" id="toc-frey-index" class="nav-link" data-scroll-target="#frey-index">4.10 Frey Index</a></li>
  <li><a href="#gamma-index" id="toc-gamma-index" class="nav-link" data-scroll-target="#gamma-index">4.11 Gamma Index</a></li>
  <li><a href="#g-plus-index" id="toc-g-plus-index" class="nav-link" data-scroll-target="#g-plus-index">4.12 G-Plus Index</a></li>
  <li><a href="#hartigan-index" id="toc-hartigan-index" class="nav-link" data-scroll-target="#hartigan-index">4.13 </a><a name="hartindex" class="nav-link" data-scroll-target="undefined"></a>Hartigan Index</li>
  <li><a href="#log-ss-ratio-index" id="toc-log-ss-ratio-index" class="nav-link" data-scroll-target="#log-ss-ratio-index">4.14 </a><a name="logssindex" class="nav-link" data-scroll-target="undefined"></a>Log SS Ratio Index</li>
  <li><a href="#marriot-index" id="toc-marriot-index" class="nav-link" data-scroll-target="#marriot-index">4.15 Marriot Index</a></li>
  <li><a href="#mcclain-index" id="toc-mcclain-index" class="nav-link" data-scroll-target="#mcclain-index">4.16 McClain Index</a></li>
  <li><a href="#point-biserial-index" id="toc-point-biserial-index" class="nav-link" data-scroll-target="#point-biserial-index">4.17 </a><a name="pbindex" class="nav-link" data-scroll-target="undefined"></a>Point-Biserial Index</li>
  <li><a href="#pseudo-t2-index" id="toc-pseudo-t2-index" class="nav-link" data-scroll-target="#pseudo-t2-index">4.18 Pseudo T2 Index</a></li>
  <li><a href="#ratkowsky-lance-index" id="toc-ratkowsky-lance-index" class="nav-link" data-scroll-target="#ratkowsky-lance-index">4.19 Ratkowsky-Lance Index</a></li>
  <li><a href="#ray-turi-index" id="toc-ray-turi-index" class="nav-link" data-scroll-target="#ray-turi-index">4.20 Ray-Turi Index</a></li>
  <li><a href="#r-squared-index" id="toc-r-squared-index" class="nav-link" data-scroll-target="#r-squared-index">4.21 </a><a name="r2index" class="nav-link" data-scroll-target="undefined"></a>R Squared Index</li>
  <li><a href="#rubin-index" id="toc-rubin-index" class="nav-link" data-scroll-target="#rubin-index">4.22 Rubin Index</a></li>
  <li><a href="#scott-symons-index" id="toc-scott-symons-index" class="nav-link" data-scroll-target="#scott-symons-index">4.23 Scott-Symons Index</a></li>
  <li><a href="#sd-index" id="toc-sd-index" class="nav-link" data-scroll-target="#sd-index">4.24 SD Index</a></li>
  <li><a href="#sdbw-index" id="toc-sdbw-index" class="nav-link" data-scroll-target="#sdbw-index">4.25 SDbw Index</a></li>
  <li><a href="#silhouette-score" id="toc-silhouette-score" class="nav-link" data-scroll-target="#silhouette-score">4.26 Silhouette Score</a></li>
  <li><a href="#tau-index" id="toc-tau-index" class="nav-link" data-scroll-target="#tau-index">4.27 Tau Index</a></li>
  <li><a href="#trace-cov-w-index" id="toc-trace-cov-w-index" class="nav-link" data-scroll-target="#trace-cov-w-index">4.28 Trace-Cov-W Index</a></li>
  <li><a href="#trace-w-index" id="toc-trace-w-index" class="nav-link" data-scroll-target="#trace-w-index">4.29 Trace-W Index</a></li>
  <li><a href="#wemmert-gancarski-index" id="toc-wemmert-gancarski-index" class="nav-link" data-scroll-target="#wemmert-gancarski-index">4.30 </a><a name="wgindex" class="nav-link" data-scroll-target="undefined"></a>Wemmert-Gancarski Index</li>
  <li><a href="#xie-beni-index" id="toc-xie-beni-index" class="nav-link" data-scroll-target="#xie-beni-index">4.31 </a><a name="xbindex" class="nav-link" data-scroll-target="undefined"></a>Xie-Beni Index</li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/N3uralN3twork/n3uraln3twork.github.io/edit/main/posts/clustering-indices-project/cluster-indices.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/N3uralN3twork/n3uraln3twork.github.io/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>The following research examines various clustering methods and internal validity indices. Many clustering algorithms depend on various assumptions in order to identify subgroups, so there exists a need to objectively evaluate these algorithms, whether through complexity analyses or the proposed internal validity indices. The goal is to apply these indices to both artificial and real data in order to assess their fidelity. Currently, there exists no Python package to achieve this goal, but the proposed library offers <span class="math inline">31</span> indices to help the user choose the correct number of clusters in his/her data, regardless of the chosen clustering methodology.</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<p>The goal of this project is to understand and compute a variety of indices that indicate the optimal number of clusters to use when performing a cluster analysis.</p>
<p>Cluster analysis refers to a finding unique subgroup/clusters in a dataset where the observations within each cluster are more related to each other in some way compared to observations in another, separate cluster. There are a plethora of clustering techniques and algorithms, each with a different way of solving the above general problem. In addition, there does not exist a single, optimal clustering solution for any clustering problem. This is also known as the “No Free Lunch” theorem from David Wolpert and William Macready, which states that “any two optimization algorthims are equivalent when their performance is averaged across all possible problems.” <a href="#NFL">(Wolpert, Macready, 2005)</a></p>
<p>Since cluster analysis is inherently an unsupervised learning technique, the selection of the optimal number of clusters is subjective. Consider the following example that was made via Python:</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_blobs</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>data, true_labels <span class="op">=</span> make_blobs(n_samples<span class="op">=</span><span class="dv">500</span>, n_features<span class="op">=</span><span class="dv">2</span>, centers <span class="op">=</span> <span class="dv">4</span>, random_state<span class="op">=</span><span class="dv">1234</span>, cluster_std<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>points <span class="op">=</span> pd.DataFrame(data, columns<span class="op">=</span>[<span class="st">'x'</span>, <span class="st">'y'</span>])</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>k4 <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">4</span>, random_state<span class="op">=</span><span class="dv">1234</span>).fit(points)</span>
<span id="cb1-12"><a href="#cb1-12"></a>k5 <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">1234</span>).fit(points)</span>
<span id="cb1-13"><a href="#cb1-13"></a>k6 <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">6</span>, random_state<span class="op">=</span><span class="dv">1234</span>).fit(points)</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span>
<span id="cb1-16"><a href="#cb1-16"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">221</span>)</span>
<span id="cb1-17"><a href="#cb1-17"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">222</span>)</span>
<span id="cb1-18"><a href="#cb1-18"></a>ax3 <span class="op">=</span> fig.add_subplot(<span class="dv">223</span>)</span>
<span id="cb1-19"><a href="#cb1-19"></a>ax4 <span class="op">=</span> fig.add_subplot(<span class="dv">224</span>)</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>ax1.scatter(points[<span class="st">'x'</span>], points[<span class="st">'y'</span>], color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb1-22"><a href="#cb1-22"></a>ax1.axes.get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-23"><a href="#cb1-23"></a>ax1.axes.get_yaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-24"><a href="#cb1-24"></a>ax2.scatter(points[<span class="st">'x'</span>], points[<span class="st">'y'</span>], c<span class="op">=</span>k4.labels_.astype(<span class="bu">float</span>))</span>
<span id="cb1-25"><a href="#cb1-25"></a>ax2.axes.get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-26"><a href="#cb1-26"></a>ax2.axes.get_yaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-27"><a href="#cb1-27"></a>ax3.scatter(points[<span class="st">'x'</span>], points[<span class="st">'y'</span>], c<span class="op">=</span>k5.labels_.astype(<span class="bu">float</span>))</span>
<span id="cb1-28"><a href="#cb1-28"></a>ax3.axes.get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-29"><a href="#cb1-29"></a>ax3.axes.get_yaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-30"><a href="#cb1-30"></a>ax4.scatter(points[<span class="st">'x'</span>], points[<span class="st">'y'</span>], c<span class="op">=</span>k6.labels_.astype(<span class="bu">float</span>))</span>
<span id="cb1-31"><a href="#cb1-31"></a>ax4.axes.get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-32"><a href="#cb1-32"></a>ax4.axes.get_yaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a>ax1.title.set_text(<span class="st">'Original Data'</span>)</span>
<span id="cb1-35"><a href="#cb1-35"></a>ax2.title.set_text(<span class="st">'K=4 Clusters'</span>)</span>
<span id="cb1-36"><a href="#cb1-36"></a>ax3.title.set_text(<span class="st">'K=5 Clusters'</span>)</span>
<span id="cb1-37"><a href="#cb1-37"></a>ax4.title.set_text(<span class="st">'K=6 Clusters'</span>)</span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\miqui\anaconda3\envs\MLDL\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning:

KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=2.

C:\Users\miqui\anaconda3\envs\MLDL\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning:

KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=2.

C:\Users\miqui\anaconda3\envs\MLDL\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning:

KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=2.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="cluster-indices_files/figure-html/cell-2-output-2.png" width="917" height="931"></p>
</div>
</div>
<p>The figure above helps to illustrate that the definition of a cluster is imprecise and that the best definition depends on the nature of the data and the user’s desired results.</p>
</section>
</section>
<section id="methods" class="level1">
<h1><strong>2. Methods</strong></h1>
<section id="language" class="level2">
<h2 class="anchored" data-anchor-id="language">2.1 Language</h2>
<p>Python was chosen as the language of choice due to the author’s familiarity with the various libraries made available in Python, including the NumPy and Sci-kit Learn modules. R was heavily used to double-check many of the algorithms and indices, relying mostly on the <strong>NbClust</strong> library <a href="#NBClust">(Charrad, 2014)</a>.</p>
</section>
<section id="related-work" class="level2">
<h2 class="anchored" data-anchor-id="related-work">2.2 Related Work</h2>
<p>A variety of measures aiming to validate the results of a cluster analysis have been defined over the years and this project focuses on relative criteria, which consists of the evaluation of a clustering algorithm by comparing it with the same algorithm but varies in the input parameters.</p>
<p>The inspiration for this project came on the heels of a separate project where a cluster analysis was used, but choosing the number of clusters appropriate for the final conclusion was unclear, both numerically and graphically. R has great support for cluster analysis and choosing the number of clusters; in particular, the <em>NbClust</em> package provides extensive support for both tasks and is the main inspiration for this project. The <em>R</em> package came out in October 2014 and contains a variety of indices that help aid the user in choosing the appropriate number of clusters, given one of two clustering methods; namely, K-Means and agglomerative clustering.</p>
<p>However, when looking to validate results in another language, there was an apalling lack of libraries available for accomplishing the task. Python lacks, and still does as of writing, a comprehensive package for choosing an appropriate number of clusters. Python’s <em>Sci-kit Learn</em> library does have support for a plethora of clustering algorithms, including the ones used in this project, as well as a few others. However, it only supports three clustering indices.</p>
<p>The three clustering indices covered by Python’s <em>Sci-kit Learn</em> library are the silhouette coefficient, the Davies-Bouldin index, and the Calinski-Harabasz index. The proposed library, as well as <em>NbClust</em>, support all three of the indices in addition to many more.</p>
</section>
</section>
<section id="clustering-algorithms" class="level1">
<h1>3. Clustering Algorithms</h1>
<p>It is worth mentioning that the algorithms discussed below are not an exhaustive list of potential clustering methods and the proposed Python package supports any method that produces predictive labels. Also, R’s <em>NbClust</em> package only supports two clustering algorithms at the moment; namely, K-Means and Hierarchical clustering.</p>
<section id="k-means" class="level2">
<h2 class="anchored" data-anchor-id="k-means">3.1 K-Means</h2>
<p>The K-Means algorithm is a centroid-based clustering technique and is one of the most popular clustering algorithms, so it had to be covered. A slight alternative to the algorithm, K-medians, uses the median instead of the mean, but will not be covered in this project. The algorithm attempts to minimize the within-cluster variances, which will be formalized next.</p>
<section id="the-k-means-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-k-means-algorithm">3.1.1 The K-Means Algorithm</h3>
<p>Given a set of <em>n</em> observations each consisting of <em>d</em> dimensions, and wanting to partition those observations into <em>k</em> clusters, the goal is to minimize the within-cluster sum of squares (WSS). Formally, the K-Means algorithm is as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="KMeans_Algorithm_Picture.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig.2 - Pseudocode for the generic K-Means algorithm</figcaption><p></p>
</figure>
</div>
<p>Initially, points are assigned to the initial centroids, which in this case is the mean. After the points are assigned to the centroid, the centroid is then updated until no more changes occur and the algorithm converges. There is no guarantee, however, that the algorithm will converge. The objective is to minimize the pairwise squared deviations of points in the same cluster:</p>
<p><span class="math display">argmin \displaystyle \sum_{i=1}^{k}\frac {1}{2 |S_i|} * \sum ||{x - y}||^{2} \tag{1}</span></p>
<p>The within cluster sum of squares, or what the <em>Sci-kit Learn</em> package calls <strong>inertia</strong>, is a measure of how internally coherent separate clusters are. The optimal value is 0 while lower values indicate more separated clusters. <em>Sci-kit Learn</em> uses Lloyd’s algorithm which follows the steps in the algorithm presented above and uses the squared Euclidean distance.</p>
</section>
<section id="time-and-space-complexity" class="level3">
<h3 class="anchored" data-anchor-id="time-and-space-complexity">3.1.2 Time and Space Complexity</h3>
<p>K-Means only needs to store the data points and each centroid. Specifically, the storage requirements for the algorithm is <span class="math inline">O(n(m + K))</span>, where m is the number of data points, n is the number of variables, and K is the pre-specified number of clusters. K-Means runs in linear time, in particular, <span class="math inline">O(I*K*m*n)</span>, where <span class="math inline">I</span> is the number of iterations until convergence. As long as the number of clusters remains significantly below the number of variables, the K-Means algorithm should run in linear time.</p>
</section>
</section>
<section id="agglomerative-hierarchical-clustering" class="level2">
<h2 class="anchored" data-anchor-id="agglomerative-hierarchical-clustering">3.2 Agglomerative Hierarchical Clustering</h2>
<p>Another commonly-used approach for clustering is that of hierarchical clustering, of which, there are two approaches; namely, Agglomerative, and Divisive.</p>
<p><strong>Agglomerative:</strong> Start with <span class="math inline">n</span> clusters and keep going until you have <span class="math inline">1</span> cluster.</p>
<p><strong>Divisive:</strong> Start with <span class="math inline">1</span> cluster and decompose until you have <span class="math inline">n</span> clusters.</p>
<p>This section will focus solely on the Agglomerative variant.</p>
<section id="agglomerative-hierarchical-clustering-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="agglomerative-hierarchical-clustering-algorithm">3.2.1 Agglomerative Hierarchical Clustering Algorithm</h3>
<p><img src="Agglomerative_Algorithm_Picture.png" class="img-fluid" data-fig-align="center" alt="Fig.3 - Pseudocode for the generic Agglomerative clustering algorithm"> The key operation of the Agglomerative Clustering algorithm is the calculation of the proximity between two clusters, where the definition of cluster proximity differentiates the various agglomerative flavors.</p>
<p>Ward’s method assumes that a cluster is represented by its centroid, but it measures the proximity between two clusters in terms of the increase in the SSE that results from merging the two clusters. Ward’s method attempts to minimize the sum of the squared distances of points from their cluster centroids. The initial cluster distances in Ward’ minimum variance method are defined to be the squared Euclidean distance between points:</p>
<p><span class="math display">d_{ij} = ||X_i - X_j||^2 \tag{2}</span></p>
</section>
<section id="time-and-space-complexity-1" class="level3">
<h3 class="anchored" data-anchor-id="time-and-space-complexity-1">3.2.2 Time and Space Complexity</h3>
<p>Ward’s method requires the storage of <span class="math inline">0.5n^{2}</span> where <span class="math inline">n</span> is the number of datapoints and the storage required to keep track of the clusters is proportional to the number of clusters, which is <span class="math inline">n-1</span>, excluding singleton clusters. Thus, the total space complexity of Ward’s method is <span class="math inline">O(n^{2})</span>.</p>
<p>Next, in terms of the time required to run the algorithm, a good place to start is the computation of the proximity matrix. <span class="math inline">O(n^{2})</span> time is required to compute the proximity matrix. Afterwards there are <span class="math inline">n-1</span> iterations involving steps <span class="math inline">3</span> and <span class="math inline">4</span> because there are <span class="math inline">n</span> clusters at the start and two clusters are merged after each iteration. In addition, because the algorithm exhaustively scans the proximity matrix for the lowest distances, the run time is <span class="math inline">O(n^{3})</span>.</p>
<p>Obviously, because of the rather large space and time complexity of the Agglomerative Clustering algorithm, it should not be used for large datasets. In addition, the Agglomerative Clustering algorithm tends to make good local decisions about which two clusters to combine since they can use information about the pairwise similarity of all of the data points. However, once a decision is made to merge two clusters, the merge is final and it cannot be undone.</p>
</section>
</section>
<section id="dbscan" class="level2">
<h2 class="anchored" data-anchor-id="dbscan">3.3 DBSCAN</h2>
<p>Density-based clustering locates regions of high density that are separated from one another by regions of low density. A cluster is considered to be a set of core samples and a set of non-core samples that are close to a core sample. In this approach, known as the <strong>center-based approach</strong>, the density for a particular point is estimated by counting the number of points within a specified radius, which is controlled by the Epsilon parameters.</p>
<p>There are three types of data points of consideration in the DBSCAN algorithm, namely:</p>
<p><strong>Core points:</strong> The points are inside the interior of a density-based cluster. A point is a core point if the number of points within a given neighborhood around the point exceeds a certain threshold, min_samples, as defined by <em>Sci-kit Learn</em>.</p>
<p><strong>Border points:</strong> A point that is not a core point, but rather falls within the neighborhood of a core point, which can fall within the neighborhood of several core points.</p>
<p><strong>Noise points:</strong> Any points that is neither a core point nor a border point.</p>
<p>An example of the three points described above are shown below:</p>
<p><img src="DBScan Points.png" class="img-fluid" data-fig-align="center" alt="Fig. 4 - Demonstration of Core, Border, and Noise points present during the usage of the DBSCAN algorithm"> ### 3.3.1 The DBSCAN algorithm</p>
<p>Informally, any two core points that are close enough, within a distance of the Epsilon parameter, are put into the same cluster. Additionally, any border point that is close enough to a core point is put in the same cluster as the core point. Finally, noise points are discarded. More formally:</p>
<p><img src="DBSCAN_Algorithm_Picture.png" class="img-fluid" data-fig-align="center" alt="Fig. 5 - Pseudocode for the generic DBSCAN clustering algorithm"> ### 3.3.2 Time and Space Complexity</p>
<p>In the worst case, the time complexity of the DBSCAN algorithm is <span class="math inline">O(n^{2})</span>, where <span class="math inline">n</span> is the number of data points, since DBSCAN visits each point of the data set. In <em>Sci-kit Learn</em>, the DBSCAN implementation uses two tree data structures, namely, ball trees and kd-trees, to determine the neighborhood of points. In particular, the kd-tree allows for the efficient retrieval of all points within a given distance of a specified points, meaning the time complexity for the DBSCAN algorithm can be as low as <span class="math inline">O(nlogn)</span></p>
<p>The implementation of the DBSCAN algorithm in <em>Sci-kit Learn</em> consumes <span class="math inline">n^{2}</span> floats, but this can be reduced to <span class="math inline">O(n)</span> since it is only necessary to store the cluster label and what type of point each datum belongs to.</p>
</section>
</section>
<section id="internal-cluster-validity-indices" class="level1">
<h1>4. Internal Cluster Validity Indices</h1>
<p>Users often have to select the best number of clusters in a data set without some indication of what the correct number of clusters should be. In addition, different clustering algorithms can lead to different clusters of the data. In addition, using different parameters for the same algorithm can also lead to different clustering results.</p>
<p>Since the need for effective evaluation standards has been described, this section will focus on a variety of indices that can be used to aid the user in selecting an appropriate amount of clusters.</p>
<section id="notation" class="level2">
<h2 class="anchored" data-anchor-id="notation">4.0 Notation:</h2>
<p>This section contains information on notations used throughout the rest of the paper.</p>
<p>Let us denote the following:</p>
<p><span class="math inline">N</span> = total number of observations in a dataset</p>
<p><span class="math inline">m</span> = the total number of numeric variables used to cluster the data</p>
<p><span class="math inline">K</span> = the total number of clusters</p>
<p><span class="math inline">X</span> = the data matrix of shape <span class="math inline">[N, m]</span></p>
<p><span class="math inline">C_{k}</span> = A submatrix of <span class="math inline">X</span> made up of the rows of <span class="math inline">X</span> where some partition, <span class="math inline">P_{i}</span>, contains any point <span class="math inline">X_{i}</span> belonging to cluster <span class="math inline">k</span></p>
<p><span class="math inline">n_{k}</span> = the number of observations belonging to cluster <span class="math inline">C_{k}</span></p>
</section>
<section id="ball-hall-index" class="level2">
<h2 class="anchored" data-anchor-id="ball-hall-index">4.1 <a name="bhindex"></a>Ball-Hall Index</h2>
<p>This index is based on the average distance of the items to their respective cluster centroids. It is just the within-group sum of distances and is computed as:</p>
<p><span class="math display">BH = \frac{W_k}{K} \tag{3}</span></p>
<p>where <span class="math inline">W_k = \displaystyle \sum ||x_i - \bar{x_i}||</span> is the within-group dispersion matrix for the data clustered into <span class="math inline">K</span> clusters. This index requires the computation of centroids and <span class="math inline">N</span> within-group distances, which itself is <span class="math inline">O(mN)</span>. Thus, Ball-Hall is <span class="math inline">O(mN)</span> where <span class="math inline">m</span> is the number of variables in the data set to be clustered.</p>
<p>The maximum difference in the Ball-Hall indices between different clusters is considered to be the optimal number of clusters.</p>
</section>
<section id="the-beale-index" class="level2">
<h2 class="anchored" data-anchor-id="the-beale-index">4.2 The Beale Index</h2>
<p><a href="#Beale">Beale, 1969</a> introduced the idea of using an F-ratio to test the hypothesis of the existence of <span class="math inline">q_1</span> versus <span class="math inline">q_2</span> clusters in the data (<span class="math inline">q_2 &gt; q_1</span>). The optimal number of clusters is obtained by comparing <span class="math inline">F</span> with an <span class="math inline">F_{p, (n_m-2)p}</span> distribution, where the null hypothesis would be rejected for significantly large values of the F-statistic. In the proposed Python package, the user can control the <span class="math inline">\alpha</span> level used to compute the critical <span class="math inline">F</span> value, and the default value is <span class="math inline">0.10</span>.</p>
<p>Mathematically, the calculation of the Beale index is as follows:</p>
<p><span class="math display">Beale = F = \frac {\frac {V_{kl}}{W_k + W_l}}{(\frac {n_m-1}{n_m-2})*2^{\frac {2}{p}}-1} \tag{4}</span></p>
<p>where <span class="math inline">V_{kl} = W_m - W_k - W_l</span> and <span class="math inline">p</span> is the number of variables.</p>
</section>
<section id="the-c-index" class="level2">
<h2 class="anchored" data-anchor-id="the-c-index">4.3 The C Index</h2>
<p>The C index was reviewed by <a href="#C_Index">Hubert and Levin, 1976</a> and is calculated below:</p>
<p><span class="math display">C_{index} = \frac {S_w - S_{min}}{S_{max} - S_{min}}, C_{index} \in (0, 1) \tag{5}</span></p>
<p>where</p>
<ul>
<li><p><span class="math inline">S_{min}</span> = the sum of the <span class="math inline">N_W</span> smallest distances between all the pairs of points in the entire data set;</p></li>
<li><p><span class="math inline">S_{max}</span> = the sum of the <span class="math inline">N_W</span> largest distances between all the pairs of points in the entire data set.</p></li>
<li><p><span class="math inline">N_{W}</span> = <span class="math inline">\displaystyle \sum_{k=1}^{K} \frac {n_k(n_k - 1)}{2}</span></p></li>
</ul>
<p>The optimal number of clusters is indicated by the minimum value of the C index. Finally, the C-index has a time complexity of <span class="math inline">O(m^{2}(n + log_2m))</span>, mostly due to the computational cost of sorting the <span class="math inline">N_W</span> pairwise distances, which can be slow with a large number of observations.</p>
</section>
<section id="the-calinski-harabasz-index" class="level2">
<h2 class="anchored" data-anchor-id="the-calinski-harabasz-index">4.4 The Calinski-Harabasz Index</h2>
<p>The Calinski-Harabasz index <a href="#CH">Calinski, Harabasz, 1974</a>, also known as the Variance Ratio Criterion, is a measure of how similar an object is to its own cluster compared to other clusters. From <em>Sci-kit Learn’s</em> website, the score is defined as the ratio between the within-cluster dispersion and between-cluster dispersion. More formally put:</p>
<p><span class="math display">CH_q = \frac{trace(B_k)/(K-1)}{trace(W_k)/(N-K)} \tag{6}</span></p>
<p>where: <span class="math display">W = \displaystyle \sum W_k \tag{7}</span></p>
<p>and: <span class="math display">W_k = \displaystyle \sum (x_i - \bar{x_m})(x_i - \bar{x_m})^{T} \tag{8}</span></p>
<p>and: <span class="math display">trace(W_k) = \displaystyle \sum_{k=1}^n \sum (x_{ip} - \bar{x_{lp}})^{2} \tag{9}</span>,</p>
<p>where <span class="math inline">x_{ip}</span> is the <span class="math inline">p^{th}</span> attribute of the <span class="math inline">i^{th}</span> data object and <span class="math inline">\bar{x_{lp}}</span> is the <span class="math inline">p^{th}</span> attribute of the centroid of the <span class="math inline">l^{th}</span> cluster.</p>
<p>The maximum value of the CH score, given a range of clusters, is considered to be the best number of clusters. The Calinski-Harabasz index also has <span class="math inline">O(mN)</span> complexity.</p>
</section>
<section id="cubic-clustering-criterion" class="level2">
<h2 class="anchored" data-anchor-id="cubic-clustering-criterion">4.5 Cubic Clustering Criterion</h2>
<p>The CCC by <a href="#CCC">Sarle, 1983</a> is obtained by comparing the observed <span class="math inline">R^2</span> to the approximate expected <span class="math inline">R^2</span> using an approximate variance-stabilizing transformation. CCC values greater than 0 mean that the obtained <span class="math inline">R^2</span> is greater than would be expected if sampling from a uniform distribution. According to the SAS Institute, the best way to use the CCC is to plot its values against the number of clusters. The CCC is used to compare the <span class="math inline">R^{2}</span> you obtain for a given set of clusters with the <span class="math inline">R^{2}</span> you would get by clustering a uniformly/normally distributed set of points in <span class="math inline">p</span> dimensional space. In addition, the optimal number of clusters is indicated by the maximum CCC value. Mathematically, the CCC can be computed as follows:</p>
<p><span class="math display">CCC = ln[\frac {1 - E[R^{2}]}{1 - R^{2}}] * \frac {\sqrt{\frac {np}{2}}}{(0.001 + E[R^{2}])^{2}} \tag{10}</span></p>
<p>where,</p>
<p><span class="math display">R^{2} = 1 - \frac {p  + \sum u^{2}_j}{\sum u^{2}_j} \tag{11}</span></p>
<p>and,</p>
<p><span class="math display">E[R^{2}] = 1 - \displaystyle \frac {\sum_{j=1}^{p} \frac {1}{n + u_j} + \sum_{j=p+1}^{p} \frac {u^{2}_j}{n + u_j}}{\displaystyle \sum^{p}_{j=1} u^{2}_{j}} * [\frac {(n - k)^{2}}{n}] * [1 + \frac {4}{n}] \tag{12}</span></p>
<p>and,</p>
<p><span class="math display">u_j = \frac {s_j}{c} \tag{13}</span></p>
<p>and,</p>
<p><span class="math display">c = (\frac {v}{k})^{\frac {1}{p}} \tag{14}</span></p>
<p>and,</p>
<p><span class="math display">v = \displaystyle \prod_{j=1}^{p} s_{j} \tag{15}</span></p>
<p>and,</p>
<p><span class="math inline">p</span> is the largest integer less than <span class="math inline">k</span> such that <span class="math inline">u_p</span> is not less than one.</p>
<p>Finally, the reason for the odd ending to the expected r-squared formula was derived empirically to stabilize the variance across different combinations of observations, variables, and clusters.</p>
</section>
<section id="d-index" class="level2">
<h2 class="anchored" data-anchor-id="d-index">4.6 D Index</h2>
<p>The D Index from <a href="#DIndex">Lebart et al., 2000</a> is based on clustering gain on intra-cluster inertia, which measures the degree of homogeneity between the data associated with a cluster. It calculates their distances compared to the cluster centroid.</p>
<p>Mathematically, intra-cluster inertia is defined as:</p>
<p><span class="math display">W(P^k) = \frac {1}{k} \displaystyle \sum_{k=1}^{K} \frac {1}{n_k} \sum_{i=1}^{n_k} d(x_i, c_k) \tag{16}</span></p>
<p>The clustering gain on the intra-cluster inertia, given two partitions, <span class="math inline">P^{k-1}</span> composed of <span class="math inline">k-1</span> clusters and <span class="math inline">P^k</span> composed of <span class="math inline">k</span> clusters, is defined as:</p>
<p><span class="math display">Gain = W(P^{k-1}) - W(P^{k}) \tag{17}</span></p>
<p>The clustering gain above should be minimized. In addition, the optimal suggested number of clusters corresponds to a significant decrease of the first different of clustering gain, compared to the number of clusters. This “significant decrease” can be identified by examining the second differences of clustering gain.</p>
</section>
<section id="davies-bouldin-index" class="level2">
<h2 class="anchored" data-anchor-id="davies-bouldin-index">4.7 Davies-Bouldin Index</h2>
<p>The <a href="#DBIndex">Davies-Bouldin Index</a> is a function of the sum ratio of within-cluster scatter to between-cluster separation. A lower value indicates a better clustering solution, i.e.&nbsp;better separation between the clusters.</p>
<p>Mathematically, the index is defined as the average similarity between each cluster and its most similar one, where the similarity is defined as a measure <span class="math inline">R_{ij}</span> that is nonnegative and symmetric, like so:</p>
<p><span class="math display">R_{ij} = \frac {s_i + s_j}{d_{ij}} \tag{18}</span></p>
<p>Then the Davies-Bouldin index is defined as:</p>
<p><span class="math display">DB = \frac {1}{k} \displaystyle \sum_{i=1}^{k}max(R_{ij}) \tag{19}</span></p>
<p>Finally, in terms of computational complexity, the Davies-Bouldin index runs in <span class="math inline">O(m(k^2 + N))</span> time.</p>
</section>
<section id="duda-index" class="level2">
<h2 class="anchored" data-anchor-id="duda-index">4.8 Duda Index</h2>
<p>The Duda index, <a href="#Duda">Duda and Hart, 1973</a> is the ratio between the sum of squared errors within clusters when the data are partitioned into two clusters, and the squared errors when only one cluster is present.</p>
<p>Mathematically, this can be represented as:</p>
<p><span class="math display">Duda = \frac {W_k + W_l}{W_m} \tag{20}</span></p>
<p>The optimal number of suggested clusters is the smallest <span class="math inline">k</span> such that:</p>
<p><span class="math display">Duda \ge 1 - \frac {2}{\pi p} - 3.20 \sqrt{\frac {2(1 - \frac {8}{\pi^{2}p}}{n_m p}} \tag{21}</span></p>
<p>where 3.20 is a Z-score tested by <a href="#MilliganCooper">Milligan and Cooper, 1985</a></p>
</section>
<section id="dunn-index" class="level2">
<h2 class="anchored" data-anchor-id="dunn-index">4.9 Dunn Index</h2>
<p>The Dunn index <a href="#Dunn">(Dunn, 1974)</a> is the ratio between the minimal intercluster distance to the maximal intracluster distance. If the data set contains well-separated clusters, the diameter of the clusters is expected to be small and the distance between the clusters should be large. Thus, the suggested optimal number of clusters corresponds to the <strong>maximum</strong> value of the Dunn index.</p>
<p>Mathematically:</p>
<p><span class="math display">Dunn = \frac {d_{min}}{d_{max}} \tag{22}</span></p>
<p>where:</p>
<p><span class="math display">d_{min} = \min{(\min{||M_{i}^{k} - M_{j}^{k'}||})} \tag{23}</span></p>
<p>and,</p>
<p><span class="math display">d_{max} = \max{(\max{||M_{i}^{k} - M_{j}^{k}||})} \tag{24}</span></p>
<p>and <span class="math inline">d_{max}</span> is known as the diameter of a cluster, or the largest distance separating two distinct points in a particular cluster.</p>
<p>In terms of computational complexity, the Dunn index runs in <span class="math inline">O(mN^{2})</span> time.</p>
</section>
<section id="frey-index" class="level2">
<h2 class="anchored" data-anchor-id="frey-index">4.10 Frey Index</h2>
<p>The Frey index,<a href="#Frey">proposed by Frey and Van Groenewoud, 1972</a>, is the ratio of the difference scores from two successive levels in a hierarchy. This means that the index should only be used on hierarchical clustering method. The numerator represents the difference between the mean between-cluster distances while the denominator represents the difference between the mean within-cluster distances, each from the two levels.</p>
<p>Mathematically, the Frey index can be written as:</p>
<p><span class="math display">Frey = \frac {\bar{S_{b_{j+1}}} - \bar{S_{b_j}}}{\bar{S_{w_{j+1}}} - \bar{S_{w_j}}} \tag{25}</span></p>
<p>where the mean between-cluster distance is:</p>
<p><span class="math display">\bar{S_b} = S_b / N_b \tag{26}</span></p>
<p>and the mean within-cluster distance is:</p>
<p><span class="math display">\bar{S_w} = S_w / N_w \tag{27}</span></p>
<p>The best clustering solution occurs when the ratio falls below 1.0, and the cluster level before that point is taken as the optimal partition. In addition, if the ratio never falls below 1.0, a one cluster solution is usually best.</p>
</section>
<section id="gamma-index" class="level2">
<h2 class="anchored" data-anchor-id="gamma-index">4.11 Gamma Index</h2>
<p>The Gamma Index compares all within-cluster dissimilarities and all between-cluster dissimilarities. A comparison is concordant/discordant if a within-cluster dissimilarity is less/greater than a between cluster dissimilarity. Ties are disregarded. Also, the maximum value of the index indicates the optimal suggested number of clusters.</p>
<p>Mathematically, the Gamma Index is defined as:</p>
<p><span class="math display">Gamma = \frac {s(+) - s(-)}{s(+) + s(-)} \tag{28}</span></p>
<p>where,</p>
<p><span class="math inline">s(+)</span> is the number of concordant comparisons</p>
<p>and,</p>
<p><span class="math inline">s(-)</span> is the number of discordant comparisons</p>
<p>Furthermore, the definition of concordant and discordant pairs is defined mathematically below:</p>
<p><span class="math display">s(+) = \frac {1}{2} \displaystyle \sum \sum \frac {1}{2} \sum \sum \delta(||x_i - x_j|| &lt; ||x_p - x_k||) \tag{29}</span></p>
<p>and,</p>
<p><span class="math display">s(-) = \frac {1}{2} \displaystyle \sum \sum \frac {1}{2} \sum \sum \delta(||x_i - x_j|| &gt; ||x_p - x_k||) \tag{30}</span></p>
<p>where,</p>
<p><span class="math inline">\delta(\cdot) = 1</span> if the corresponding inequality is satisfied and <span class="math inline">\delta(\cdot) = 0</span> otherwise.</p>
<p>In terms of computational complexity, this index requires the computation of all pairwise distances between objects, which itself is <span class="math inline">O(mN^{2})</span>. In addition, computing <span class="math inline">s(+)</span> and <span class="math inline">s(-)</span> requires <span class="math inline">O(\frac {N^{4}}{k})</span> time, so the total computational cost of the Gamma index is <span class="math inline">O(mN^{2} + \frac {N^{4}}{k})</span>. This index should almost never be used for large data sets as it is very resource heavy. The performance of this particular index, along with the G+ and Tau indices, will be discussed in the performance section later on.</p>
</section>
<section id="g-plus-index" class="level2">
<h2 class="anchored" data-anchor-id="g-plus-index">4.12 G-Plus Index</h2>
<p>The G+ index is another metric based on the relationships between just the discordant pairs of objects, <span class="math inline">s(-)</span>. It is simply the proportion of discordant pairs with respect to the maximum number of possible comparisons. The optimal number of clusters in the data is given by the minimum value of the index.</p>
<p>Mathematically, the index can be computed as:</p>
<p><span class="math display">G+ = \frac {2s(-)}{N_t * (N_t - 1)} \tag{31}</span></p>
<p>The computational run time of the G+ index is also <span class="math inline">O(mN^{2} + \frac {N^{4}}{k})</span> and as such should not be used for larger data sets.</p>
</section>
<section id="hartigan-index" class="level2">
<h2 class="anchored" data-anchor-id="hartigan-index">4.13 <a name="hartindex"></a>Hartigan Index</h2>
<p>The Hartigan index is based on the Euclidean within-cluster sums of squares. The optimal number of clusters is given by the maximum difference between successive clustering solutions.</p>
<p>Mathematically, it can be expressed as:</p>
<p><span class="math display">Hartigan = (W_k / W_{k+1}) * (N - K - 1) \tag{32}</span></p>
<p>where <span class="math inline">W_k = \displaystyle \sum ||x_i - \bar{x_i}||</span> is the within-cluster dispersion matrix for the data clustered into <span class="math inline">K</span> clusters</p>
<p>The computational run time of the Hartigan index is <span class="math inline">O(n(k^{2} + m))</span> and is discussed in further detail ahead.</p>
</section>
<section id="log-ss-ratio-index" class="level2">
<h2 class="anchored" data-anchor-id="log-ss-ratio-index">4.14 <a name="logssindex"></a>Log SS Ratio Index</h2>
<p>This index, from <a href="https://people.inf.elte.hu/fekete/algoritmusok_msc/klaszterezes/John%20A.%20Hartigan-Clustering%20Algorithms-John%20Wiley%20&amp;%20Sons%20(1975).pdf">J. A. Hartigan. Clustering algorithms. New York: Wiley, 1975.</a> considers the within (<span class="math inline">WGSS</span>) and between (<span class="math inline">BGSS</span>) cluster sums of squares. It should be noted that the log used is base <span class="math inline">10</span>, not <span class="math inline">e</span>.</p>
<p>The time complexity of this index is, at worst, <span class="math inline">O(n(k^{2} + m))</span> and at best <span class="math inline">O(nm)</span> when <span class="math inline">k^{2} &lt;&lt; m</span>. Thus, this index is ideal for data with naturally large clusters.</p>
</section>
<section id="marriot-index" class="level2">
<h2 class="anchored" data-anchor-id="marriot-index">4.15 Marriot Index</h2>
<p>The Marriot Index <a href="#Marriot">Marriot, 1971</a> is based on the determinant of the within-group covariance matrix.</p>
<p>Mathematically, it is computed as:</p>
<p><span class="math display">k^{2} * det(W_{k}) \tag{33}</span></p>
<p>The suggested optimal number of clusters is based on the maximum difference between successive levels of the Marriot index. The overall computational complexity of the Marriot index is <span class="math inline">O(m^{2}N + m^{3})</span>, making it suitable for large datasets with a medium number of dimensions.</p>
</section>
<section id="mcclain-index" class="level2">
<h2 class="anchored" data-anchor-id="mcclain-index">4.16 McClain Index</h2>
<p>The McClain and Rao index <a href="#McClain">McClain and Rao, 1975</a> is the ratio of the average within cluster distance - divided by the number of within cluster distances - and the average value between cluster distances - divided by the number of cluster distances.</p>
<p>Mathematically, it is formed by:</p>
<p><span class="math display">McClain = \frac {\bar{S_w}}{\bar{S_b}}  = \frac {S_w / N_w}{S_b / N_b} \tag{34}</span></p>
<p>The optimal suggested number of clusters corresponds to the minimum value of the index. Finally, in terms of computational complexity, the McClain Rao index runs in <span class="math inline">O(mN^{2})</span> time.</p>
</section>
<section id="point-biserial-index" class="level2">
<h2 class="anchored" data-anchor-id="point-biserial-index">4.17 <a name="pbindex"></a>Point-Biserial Index</h2>
<p>The Point Biserial index is the point-biserial correlation between the dissimilarity matrix and a corresponding matrix consisting of either 0’s or 1’s. A value of <span class="math inline">0</span> is assigned if the two corresponding points are clustered together by the algorithm and <span class="math inline">1</span> otherwise.</p>
<p>Mathematically, the index is defined as:</p>
<p><span class="math display">PB = \displaystyle \frac {[\bar{S_b} - \bar{S_w}] * \sqrt{[N_w*N_b/N_t^2]}}{s_d} \tag{35}</span></p>
<p>where,</p>
<p><span class="math display">\bar{S_w} = S_{w} / N_{w} \tag{36}</span></p>
<p>and,</p>
<p><span class="math display">\bar{S_b} = S_b / N_b \tag{37}</span></p>
<p>and,</p>
<p><span class="math display">s_d \tag{38}</span></p>
<p>is the standard deviation over all of the distances</p>
<p>and,</p>
<p><span class="math inline">N_k</span> = The number of data points in each cluster, so an array of length <span class="math inline">K</span></p>
<p><span class="math inline">N_{T}</span> = <span class="math inline">\frac {N*(N-1)}{2}</span> = Total number of pairs of distinct points in the data set.</p>
<p><span class="math inline">N_{W}</span> = <span class="math inline">\displaystyle \frac {n_k * (n_k - 1)}{2}</span> = The number of paris of points belonging to clusters <span class="math inline">k</span> and <span class="math inline">k'</span>.</p>
<p><span class="math inline">N_{B}</span> = <span class="math inline">\displaystyle \sum_{k&lt;k'} {n_k * (n_{k'})}</span> = The number of pairs of points belonging to clusters <span class="math inline">k</span> and <span class="math inline">k'</span> where <span class="math inline">k</span> and <span class="math inline">k'</span> are not the same cluster.</p>
<p>In terms of computational complexity, the Point-Biserial index takes <span class="math inline">O(nm^{2})</span> time to be computed.</p>
</section>
<section id="pseudo-t2-index" class="level2">
<h2 class="anchored" data-anchor-id="pseudo-t2-index">4.18 Pseudo T2 Index</h2>
<p>The Pseudo <span class="math inline">t^{2}</span> index from <a href="#PsuedoT2">Duda and Hart, 1973</a> can only be applied to hierarchical clustering methods, but is included for all clustering methods in the proposed Python package. This is because the user should understand that the metric should only be used for that specific method.</p>
<p>Mathematically, the index is computed as:</p>
<p><span class="math display">Pseudo-t^{2} = \frac {V_{kl}}{\frac {W_k + W_l}{n_k + n_l - 2}} \tag{39}</span></p>
<p>The suggested optimal number of clusters is based on the smallest <span class="math inline">q</span> such that:</p>
<p><span class="math display">Pseudo-t^{2} \le (\displaystyle \frac {1 - CritValue}{CritValue}) \times (n_k + n_l -2) \tag{40}</span></p>
</section>
<section id="ratkowsky-lance-index" class="level2">
<h2 class="anchored" data-anchor-id="ratkowsky-lance-index">4.19 Ratkowsky-Lance Index</h2>
<p>The <a href="#RLIndex">Ratkowsky and Lance, 1978</a> index is based on the average of the ratio between the between-group sum of squares and the total sum of squares for each variable.</p>
<p>Mathematically, it is computed as:</p>
<p><span class="math display">RL = \frac {\bar{S}}{K^{1/2}} \tag{41}</span></p>
<p>where,</p>
<p><span class="math display">\bar{S^{2}} = \frac {1}{p}\displaystyle \sum_{j=1}^{p} \frac {BGSS_j}{TSS_j} \tag{42}</span></p>
<p>and,</p>
<p><span class="math display">BGSS_j = \displaystyle \sum_{k=1}^{m}n_k*(c_{kj} - \bar{x_j})^{2} \tag{43}</span></p>
<p>and,</p>
<p><span class="math display">TSS_j = \displaystyle \sum_{i=1}^{n} (x_{ij} - \bar{x_j})^{2} \tag{44}</span></p>
<p>The optimal number of clusters is suggested by the maximum value of the index. Finally, the index runs in <span class="math inline">O(m(k^{2} + N))</span> time.</p>
</section>
<section id="ray-turi-index" class="level2">
<h2 class="anchored" data-anchor-id="ray-turi-index">4.20 Ray-Turi Index</h2>
<p>This index, proposed by <a href="#Ray-Turi">Ray and Turi in 1999</a>, came off of the heels of image segmentation, which separates parts of images into differing components. The index is simply the ratio between the intra-cluster distance and the inter-cluster distance.</p>
<p>Mathematically, it can be written as:</p>
<p><span class="math display">RT = \frac {intra}{inter} \tag{45}</span></p>
<p>where:</p>
<p><span class="math display">intra = \frac {1}{N} \displaystyle \sum_{i=1}^{k} \sum ||x - c_{k}||^{2} \tag{46}</span></p>
<p>and,</p>
<p><span class="math display">inter = min(||c_{k} - c_{k+1}||^{2}) \tag{47}</span></p>
<p>and <span class="math inline">c_k</span> is the centroid of cluster <span class="math inline">C_{k}</span></p>
<p>Since the goal is to minimize the intra-cluster distance - the numerator - the optimal cluster partitioning corresponds to the minimum value of the Ray-Turi index.</p>
</section>
<section id="r-squared-index" class="level2">
<h2 class="anchored" data-anchor-id="r-squared-index">4.21 <a name="r2index"></a>R Squared Index</h2>
<p>While not included as part of the <em>NbClust</em> standard library, the <span class="math inline">R^{2}</span> index is inherently necessary to compute, since it is relied upon by the cubic clustering criterion, as mentioned above. The maximum difference between successive clustering levels is regarded as the best partition. The mathematical formulation is as follows:</p>
<p><span class="math display">R^{2} = 1 - \frac {p  + \sum u^{2}_j}{\sum u^{2}_j} \tag{48}</span></p>
<p><span class="math display">R^{2} = 1 - \frac {tr(X^{T}X - \bar{X}^{T}Z^{T}Z\bar{X})}{tr(X^{T}X)} \tag{49}</span></p>
<p>where:</p>
<p><span class="math display">\bar{X} = (Z^{T}Z)^{-1}Z^{T}X \tag{50}</span></p>
<p>and,</p>
<p><span class="math display">X^{T}X \tag{51}</span></p>
<p>is the total sum of squares and cross-products matrix of shape <span class="math inline">(p \times p)</span>.</p>
</section>
<section id="rubin-index" class="level2">
<h2 class="anchored" data-anchor-id="rubin-index">4.22 Rubin Index</h2>
<p>The Rubin Index, proposed by <a href="#Rubin">Friedman and Rubin in 1967</a>, is based on the ratio of the determinants of the data covariance matrix and within-group covariance matrix.</p>
<p>Mathematically, it can be formed like so:</p>
<p><span class="math display">Rubin = \frac {det(T)}{det(W_k)} \tag{52}</span></p>
<p>The optimal clustering solution is given by the minimum value of the second differences between clustering levels. In terms of computational complexity, the Rubin index runs in <span class="math inline">O(m^{2}N + m^{3})</span> time.</p>
</section>
<section id="scott-symons-index" class="level2">
<h2 class="anchored" data-anchor-id="scott-symons-index">4.23 Scott-Symons Index</h2>
<p>The Scott-Symons index, <a href="#Scott-Symons">Scott and Symons, 1971</a>, uses information from the determinants of the data covariance matrix and the within-group covariance matrix, similar to the Rubin index.</p>
<p>Mathematically, it can be written as:</p>
<p><span class="math display">n*log(\frac {det(T)}{det(W_k)}) \tag{53}</span></p>
<p>where:</p>
<p><span class="math display">T = \displaystyle \sum_{i=1}^{N} (x_i - \bar{x})(x_i - \bar{x})^{T}</span></p>
<p>and,</p>
<p><span class="math display">W_k = \displaystyle \sum (x_i - \bar{x_m})(x_i - \bar{x_m})^{T} \tag{54}</span></p>
<p>The optimal suggested number of clusters is given by the maximum value of the index. Finally, the index runs in <span class="math inline">O(m^{2}N + m^{3})</span> time.</p>
</section>
<section id="sd-index" class="level2">
<h2 class="anchored" data-anchor-id="sd-index">4.24 SD Index</h2>
<p>The SD validity index is based on the concepts of average scattering for clusters and total separation between clusters.</p>
<p>Mathematically, it is computed as:</p>
<p><span class="math display">SDindex(q) = \alpha*Scat(q) + Dis(q) \tag{55}</span></p>
<p>The scattering term, or the average compactness of clusters, is computed as:</p>
<p><span class="math display">Scat(q) = \frac {\frac {1}{q} \sum ||\sigma^{k}||}{||\sigma||} \tag{56}</span></p>
<p>where:</p>
<p><span class="math display">Dis(q) = \frac {D_{max}}{D_{min}} \displaystyle \sum_{k=1}^{q} (\sum_{z=1}^{q}||c_k - c_z||)^{-1} \tag{57}</span></p>
<p>and <span class="math inline">D_{max}</span> is the maximum distance between cluster centers and <span class="math inline">D_{min}</span> is the minimum distance between cluster centers. In addition, <span class="math inline">\sigma</span> is the vector of variances for each variable in the data set and <span class="math inline">\sigma^{k}</span> is the variance vector for each cluster, <span class="math inline">C_k</span>.</p>
<p>It should be noted that <span class="math inline">\alpha</span> is a weighting factor equal to Dis(<span class="math inline">q_{max}</span>) where <span class="math inline">q_{max}</span> is the maximum number of clusters. The optimal suggested number of clusters is indicated by the minimum value of the SD index.</p>
</section>
<section id="sdbw-index" class="level2">
<h2 class="anchored" data-anchor-id="sdbw-index">4.25 SDbw Index</h2>
<p>The SDbw index is based on the compactness and separation between clusters.</p>
<p>Mathematically, it can be computed as:</p>
<p><span class="math display">SDbw(q) = Scat(q) + Density(q) \tag{58}</span></p>
<p>where:</p>
<p><span class="math display">Density(q) = \frac {1}{q(q-1)} \displaystyle \sum_{i=1}^{q} (\sum_{j=1}^{q} \frac {density(u_{ij})}{max(density(c_i), density(c_j)}) \tag{59}</span></p>
<p>and,</p>
<p><span class="math display">density(u_{ij}) = \displaystyle \sum_{l=1}^{n_{ij}} f(x_l, u_{ij}) \tag{60}</span></p>
<p>The <span class="math inline">Scat(q)</span> term is calculated in the same way as above. The new term - <span class="math inline">Density(q)</span> - is the inter-cluster density, which is the average density in the region among clusters in relation to the density of the clusters.</p>
<p>The optimal number of clusters is the partition that minimizes the SDbw index.</p>
</section>
<section id="silhouette-score" class="level2">
<h2 class="anchored" data-anchor-id="silhouette-score">4.26 Silhouette Score</h2>
<p>Introduced by <a href="#Silhouette">Rousseeuw in 1987</a>, the Silhouette Coefficient is composed of two scores:</p>
<ul>
<li><p><strong>a:</strong> The mean distance between a sample and all other points in the same class</p></li>
<li><p><strong>b:</strong> The mean distance between a sample and all other points in the next nearest cluster</p></li>
</ul>
<p>Mathematically, this can be written as:</p>
<p><span class="math display">s = \frac {b - a}{max(a, b)} \tag{61}</span></p>
<p>Additionally, the Silhouette Score for a set of sample is just the mean Silhouette Coefficient for each sample, like so:</p>
<p><span class="math display">Silhouette = \frac {\sum_{i=1}^{n} S(i)}{n} \tag{62}</span></p>
<p>where:</p>
<p><span class="math display">a = \frac {\sum d_{ij}}{n_r - 1} \tag{63}</span></p>
<p>and,</p>
<p><span class="math display">b = min(d_{iCs}) \tag{64}</span></p>
<p>and,</p>
<p><span class="math display">d_{iCs} = \frac {\sum d_{ij}}{n_s} \tag{65}</span></p>
<p>The optimal number of clusters is indicated by the maximum value of the index. Scores around <span class="math inline">0</span> indicate overlapping clusters. Finally, the index can be calculated in <span class="math inline">O(mN^{2})</span> time.</p>
</section>
<section id="tau-index" class="level2">
<h2 class="anchored" data-anchor-id="tau-index">4.27 Tau Index</h2>
<p>The Tau index is based on the <span class="math inline">\tau</span> correlation between the matrix that stores all of the distances between pairs of observations and a matrix that represents whether a given pair of observations belongs to the same cluster or not. It can be written in terms of concordant and discordant pairs of observations, just like the Gamma and G+ indices.</p>
<p>Mathematically, it can be written as:</p>
<p><span class="math display">\displaystyle \frac {s(+) - s(-)}{\sqrt{[(N_t (N_t - 1) / (2 - t)) * (N_t (N_t - 1) / 2)]}} \tag{66}</span></p>
<p>where <span class="math inline">N_t</span> is the total number of distances and <span class="math inline">t</span> is the number of comparisons between two pairs of observations.</p>
<p>The optimal suggested clustering solution is given by the maximum value of this index. In terms of computational complexity, the Tau index runs in the same time as the Gamma index; namely, <span class="math inline">O(mN^{2} + \frac {N^{4}}{k})</span> making it suitable for small datasets.</p>
</section>
<section id="trace-cov-w-index" class="level2">
<h2 class="anchored" data-anchor-id="trace-cov-w-index">4.28 Trace-Cov-W Index</h2>
<p>The Trace(Cov(W)) index involves using the pooled covariance matrix instead of the within-group covariance matrix.</p>
<p>Mathematically, it can be written as:</p>
<p><span class="math display">TraceCovW = trace(COV[W_k]) = trace(W_p) \tag{67}</span></p>
<p>where:</p>
<p><span class="math display">W_k = \displaystyle \sum \sum (x_i - c_k)(x_i - c_k)^{T} \tag{68}</span></p>
<p>and,</p>
<p><span class="math display">W_p = \frac {1}{N-k} * \displaystyle \sum_{i=1}^{k}W_i \tag{69}</span></p>
<p>and,</p>
<p><span class="math display">W_i = \displaystyle \sum(x_i - \bar{x_i})(x_i - \bar{x_i})^{T} \tag{70}</span></p>
<p>The optimal suggested number of clusters is indicated by the maximal difference in index scores. Finally, in terms of computational efficiency, the index can be calculated in <span class="math inline">O(mN)</span> time, making it ideal for larger data sets.</p>
</section>
<section id="trace-w-index" class="level2">
<h2 class="anchored" data-anchor-id="trace-w-index">4.29 Trace-W Index</h2>
<p>The Trace(W) index is a simple, difference-like criterion and is one of the most popular choices when selecting the appropriate number of clusters.</p>
<p>Mathematically, it can be calculated as:</p>
<p><span class="math display">Trace(W) = trace(W_k) \tag{71}</span></p>
<p>where <span class="math inline">W_k</span> is the within-group covariance matrix.</p>
<p>The optimal suggested number of clusters corresponds to the maximum value of the second differences of the index. Finally, in terms of computational complexity, the index runs in <span class="math inline">O(mN)</span> time, making it ideal for large data sets.</p>
</section>
<section id="wemmert-gancarski-index" class="level2">
<h2 class="anchored" data-anchor-id="wemmert-gancarski-index">4.30 <a name="wgindex"></a>Wemmert-Gancarski Index</h2>
<p>The Wemmert-Gancarski index, is simply the weighted mean of the quotient of distances between a set of points and the barycenter of the cluster those points belong to.</p>
<p>Mathematically, it can be calculated as:</p>
<p><span class="math display">WG = \displaystyle \frac {1}{N} \sum_{k=1}^{K} \max{(0, n_k - \sum_{i \in I_k} R(M_i))} \tag{72}</span></p>
<p>where:</p>
<p><span class="math display">R(M_i) = \displaystyle \frac {||M_i - G^{k}||}{\displaystyle \min_{k \ne k'} ||M_i - G^{k'}||} \tag{73}</span></p>
<p>and,</p>
<p><span class="math display">n_k = |x_{k}| \tag{74}</span></p>
<p>is the cardinality / number of points in a particular cluster</p>
<p>and:</p>
<p><span class="math display">\displaystyle \sum_{k=1}^{K} n_k = N \tag{75}</span></p>
</section>
<section id="xie-beni-index" class="level2">
<h2 class="anchored" data-anchor-id="xie-beni-index">4.31 <a name="xbindex"></a>Xie-Beni Index</h2>
<p>The Xie-Beni index is an index primarily applied to fuzzy clustering solutions. It is defined as the quotient between the mean quadratic error and the minimum of the minimal squared distances between the points in the clusters.</p>
<p>Mathematically, the index can be calculated as:</p>
<p><span class="math display">XB = \frac {1}{N} * \frac {WGSS}{min(D(C_k, C_{k'})^{2})} \tag{76}</span></p>
<p>where:</p>
<p><span class="math display">D(C_k, C_{k'}) = min(d(M_i, M_j)) \tag{77}</span></p>
<p>and <span class="math inline">d(M_i, M_j)</span> is the distance between the cluster centroids.</p>
<p>The optimal suggested number of clusters corresponds to the minimum value of the index.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">© CC-By Matthias Quinn, 2022</div>   
    <div class="nav-footer-right">This page is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</div>
  </div>
</footer>



</body></html>